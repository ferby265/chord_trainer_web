<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Chord Trainer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <style>
        /* Additional styles for menu and app screens */
    </style>
</head>

<body>
    <!-- Menu Screen (shown on load) -->
    <div id="menuScreen" class="menu-screen">
        <button onclick="selectMode('spell')">Spell Chord</button>
        <button onclick="selectMode('name')">Name Chord</button>
        <button onclick="selectMode('scale')">Scales</button>
        <button onclick="selectMode('degrees')">Degrees</button>
        <button onclick="selectMode('harmony')">Harmony</button>
        <button onclick="selectMode('progression')">Progressions</button>
    </div>

    <!-- App Screen (hidden on load) -->
    <div id="appScreen" class="hidden">
        <button onclick="goBackToMenu()" class="back-button">‚Üê Menu</button>
        <div class="app-wrapper">
            <div class="app-container">
                <div id="chordDisplay">Press "Generate Chord" to start!</div>
                <div class="input-submit-group">
                    <form id="answerForm" class="input-form">
                        <input type="text" id="userInput" placeholder="Enter notes (space-separated)"
                            autocomplete="off" />
                        <button type="submit" class="submit-btn">Submit</button>
                    </form>
                </div>
                <button onclick="generateQuestion()" id="generateButton">Generate</button>
                <select id="difficulty">
                    <option value="easy">Easy</option>
                    <option value="medium">Medium</option>
                    <option value="hard">Hard</option>
                    <option value="competition">Competition</option>
                </select>
                <button type="button" class="help-button-fixed" onclick="toggleHelp()">Help</button>
                <div id="helpPopup" class="help-popup hidden">
                    <p><strong>Easy:</strong> Basic triads, sus chords, basic 7ths, 6th chords, add chords.</p>
                    <p><strong>Medium:</strong> Adds 9ths, 11ths, 13ths, suspended dominants.</p>
                    <p><strong>Hard:</strong> Adds altered dominants, diminished, minMaj7, accidentals.</p>
                    <p><strong>Competition:</strong> Same as Hard but with a 15s timer.</p>
                    <p><strong>Shell Mode:</strong> Reduces chords to Root, 3rd, 7th, and essential extensions.</p>
                </div>
                <p id="feedback" class="feedback-container"></p>
                <div class="bottom-container">
                    <div class="time-container">
                        <p id="timerDisplay">Timer: --s</p>
                        <p id="averageTimeDisplay">Average Time: --s</p>
                    </div>
                    <div class="score-shell-wrapper">
                        <p id="scoreDisplay">Score: 0 / 0</p>
                        <div class="shell-toggle-wrapper" onclick="toggleModeToggle()">
                            <span id="shellCheckbox" class="shell-checkbox">‚òê</span>
                            <span id="shellToggle" class="shell-icon">üêö Shell Mode</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global Variables
        console.log("SCRIPT LOADED!");
        let timer;
        let timeLeft = 15;
        let correctNotes = [];
        let correctCount = 0;
        let shellModeActive = false;
        let totalCount = 0;
        let intervals = [];
        let totalTimeSpent = 0;
        let answerCount = 0;
        let currentMode = 'spell'; // Default mode
        let startTime;
        let currentDifficulty = 'easy';
        let root;
        let chordType;
        // Degrees/Harmony modes
        let harmonyTargetDegree = null;   // e.g. "b2"
        let harmonyCorrectNote = null;    // e.g. "Eb"
        let harmonyDegreeRoman = null;    // e.g. "II"
        let harmonyChordName = null;      // e.g. "Bm7"
        let harmonyChordQuality = null;   // e.g. "min7"
        let harmonyChordRoot = null;      // e.g. "B"
        let outOfScaleAllowed = false;
        // Progression mode state
        let progressionChords = [];
        let progressionRoot = null;
        let progressionScaleType = null;
        let progressionBorrowedIndex = null;
        let progressionBorrowedChord = null;

        // Helper: Note to pitch class conversion
        function noteToPitchClass(note) {
            const pitchClasses = {
                'C': 0, 'B#': 0, 'Dbb': 0, 'C#': 1, 'Db': 1, 'D': 2, 'C##': 2, 'Ebb': 2,
                'D#': 3, 'Eb': 3, 'E': 4, 'Fb': 4, 'F': 5, 'E#': 5, 'F#': 6, 'Gb': 6,
                'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11, 'Cb': 11
            };
            return pitchClasses[note];
        }

        function arraysEqual(a, b) {
            return a.length === b.length && a.every((v, i) => v === b[i]);
        }

        // Menu switching functions
        function selectMode(mode) {
            currentMode = mode;
            resetStats();
            updateToggleUI();
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('appScreen').classList.remove('hidden');
        }

        function goBackToMenu() {
            document.getElementById('menuScreen').classList.remove('hidden');
            document.getElementById('appScreen').classList.add('hidden');
        }

        function toggleShellMode() {
            shellModeActive = !shellModeActive;
            document.getElementById('shellCheckbox').innerText = shellModeActive ? '‚òëÔ∏è' : '‚òê';
            document.getElementById('shellToggle').style.color = shellModeActive ? 'black' : '#aaa';
        }

        // Interval labels
        const intervalLabels = {
            0: '1', 1: 'b2', 2: '2', 3: 'b3', 4: '3', 5: '4', 6: 'b5', 7: '5', 8: '#5',
            9: '6', 10: 'b7', 11: '7', 13: 'b9', 14: '9', 15: '#9', 17: '11', 18: '#11',
            20: 'b13', 21: '13', 22: '#13',
        };

        // Generate chord function (fetches chord from server)
        function generateChord() {
            const difficulty = document.getElementById('difficulty').value;

            if (difficulty !== currentDifficulty) {
                totalTimeSpent = 0;
                answerCount = 0;
                updateAverageTime();
                currentDifficulty = difficulty;
            }

            fetch(`/generate_chord?difficulty=${difficulty}&shell_mode=${shellModeActive}`)
                .then(response => response.json())
                .then(data => {
                    root = data.root;
                    chordType = data.chord_type;
                    correctNotes = data.correct_notes;
                    intervals = data.intervals;

                    if (currentMode === 'spell') {
                        document.getElementById('chordDisplay').innerText =
                            `Spell the notes in: ${formatChordJazz(root, chordType)}`;
                    } else if (currentMode === 'name') {
                        document.getElementById('chordDisplay').innerText =
                            `Name this chord: ${correctNotes.join(' ')}`;
                    }

                    document.getElementById('feedback').innerText = "";
                    document.getElementById('userInput').value = "";
                    startTimer(difficulty);
                    startTime = Date.now();
                })
                .catch(error => {
                    console.error("Error fetching chord:", error);
                    document.getElementById('feedback').innerText =
                        "‚ùå Failed to get a new chord. Check console.";
                });
        }
        function generateProgression() {
            const difficulty = document.getElementById('difficulty').value;

            let endpoint = "/generate_progression_easy";
            if (difficulty === "medium") endpoint = "/generate_progression_medium";
            if (difficulty === "hard" || difficulty === "competition") endpoint = "/generate_progression_hard";

            fetch(`${endpoint}?difficulty=${difficulty}`)
                .then(r => r.json())
                .then(data => {
                    progressionRoot = data.root;
                    progressionScaleType = data.scale_type;
                    progressionChords = data.chords || [];

                    progressionBorrowedIndex = (data.borrowed_index ?? null);
                    progressionBorrowedChord = (data.borrowed_chord ?? null);

                    const prettyScale = (progressionScaleType || "").replaceAll("_", " ");
                    const chordsLine = progressionChords.map(prettyChordString).join("   ");

                    if (difficulty === "easy") {
                        document.getElementById('chordDisplay').innerText =
                            `What scale fits these chords?\n${chordsLine}`;
                    } else if (difficulty === "medium") {
                        document.getElementById('chordDisplay').innerText =
                            `In ${progressionRoot} ${prettyScale}, which chord doesn't belong?\n${chordsLine}`;
                    } else {
                        document.getElementById('chordDisplay').innerText =
                            `Hard: name the scale AND the borrowed chord.\nChords:\n${chordsLine}\n\nFormat: "C ionian | Abmaj7"`;
                    }

                    document.getElementById('feedback').innerText = "";
                    document.getElementById('userInput').value = "";
                    startTimer(difficulty);
                    startTime = Date.now();
                })
                .catch(err => {
                    console.error(err);
                    document.getElementById('feedback').innerText = "‚ùå Failed to get a progression question.";
                });
        }
        function startTimer(difficulty) {
            clearInterval(timer);
            timeLeft = difficulty === 'competition' ? 15 : 30;
            timer = setInterval(() => {
                document.getElementById('timerDisplay').innerText = `Timer: ${timeLeft}s`;
                timeLeft--;
                if (timeLeft < 0) clearInterval(timer);
            }, 1000);
        }

        function checkAnswer() {
            // --- DEGREES MODE (degree -> note) ---
            if (currentMode === 'degrees') {
                if (!harmonyCorrectNote) {
                    document.getElementById('feedback').innerText = "‚ùå Generate a degrees question first!";
                    return;
                }

                const userAnswer = document.getElementById('userInput').value.trim();
                clearInterval(timer);

                const endTime = Date.now();
                const timeTaken = (endTime - startTime) / 1000;
                totalTimeSpent += timeTaken;
                answerCount++;
                totalCount++;

                const userPC = noteToPitchClass(userAnswer);
                const correctPC = noteToPitchClass(harmonyCorrectNote);

                if (userPC === correctPC) {
                    correctCount++;
                    document.getElementById('feedback').innerText = "‚úÖ Correct!";
                    updateScore();
                    updateAverageTime();
                    setTimeout(generateQuestion, 800);
                    return;
                }

                document.getElementById('feedback').innerHTML = `‚ùå Incorrect!<br><strong>Correct:</strong> ${harmonyCorrectNote}`;
                updateScore();
                updateAverageTime();
                return;
            }

            // --- HARMONY MODE (degree -> chord) ---
            if (currentMode === 'harmony') {
                if (!harmonyChordQuality || !harmonyChordName) {
                    document.getElementById('feedback').innerText = "‚ùå Generate a harmony question first!";
                    return;
                }

                const userAnswer = document.getElementById('userInput').value.trim();
                clearInterval(timer);

                const endTime = Date.now();
                const timeTaken = (endTime - startTime) / 1000;
                totalTimeSpent += timeTaken;
                answerCount++;
                totalCount++;

                const parsed = parseChordAnswer(userAnswer);
                const expectedRootPC = noteToPitchClass(harmonyChordRoot);

                if (parsed && parsed.rootPC === expectedRootPC && parsed.qualityKey === harmonyChordQuality) {
                    correctCount++;
                    document.getElementById('feedback').innerText = "‚úÖ Correct!";
                    updateScore();
                    updateAverageTime();
                    setTimeout(generateQuestion, 800);
                    return;
                }

                document.getElementById('feedback').innerHTML =
                    `‚ùå Incorrect!<br><strong>Correct chord:</strong> ${prettyChordString(harmonyChordName)}`;
                updateScore();
                updateAverageTime();
                return;
            }
            // --- PROGRESSION MODE ---
            if (currentMode === 'progression') {
                if (!progressionChords.length) {
                    document.getElementById('feedback').innerText = "‚ùå Generate a progression first!";
                    return;
                }

                const difficulty = document.getElementById('difficulty').value;
                const userAnswerRaw = document.getElementById('userInput').value.trim();
                clearInterval(timer);

                const endTime = Date.now();
                const timeTaken = (endTime - startTime) / 1000;
                totalTimeSpent += timeTaken;
                answerCount++;
                totalCount++;

                const prettyScale = (progressionScaleType || "").replaceAll("_", " ");
                const expectedScaleTokens = [
                    `${progressionRoot}`.toLowerCase(),
                    `${prettyScale}`.toLowerCase()
                ];

                const normalize = (s) => (s || "").toLowerCase().replaceAll(/\s+/g, " ").trim();

                const isScaleMatch = (s) => {
                    const x = normalize(s);
                    // accept: "C major", "C ionian", "c natural minor", etc
                    return x.includes(expectedScaleTokens[0]) && x.includes(expectedScaleTokens[1]);
                };

                if (difficulty === "easy") {
                    if (isScaleMatch(userAnswerRaw)) {
                        correctCount++;
                        document.getElementById('feedback').innerText = "‚úÖ Correct!";
                        updateScore(); updateAverageTime();
                        setTimeout(generateQuestion, 900);
                        return;
                    }
                    document.getElementById('feedback').innerHTML =
                        `‚ùå Incorrect!<br><strong>Answer:</strong> ${progressionRoot} ${prettyScale}`;
                    updateScore(); updateAverageTime();
                    return;
                }

                if (difficulty === "medium") {
                    const x = normalize(userAnswerRaw);
                    const borrowed = normalize(progressionBorrowedChord);

                    // accept either the exact chord name or the index number (1..N)
                    const asIndex = parseInt(x, 10);
                    const indexOk = (!Number.isNaN(asIndex) && asIndex === (progressionBorrowedIndex + 1));
                    const chordOk = x === borrowed;

                    if (indexOk || chordOk) {
                        correctCount++;
                        document.getElementById('feedback').innerText = "‚úÖ Correct!";
                        updateScore(); updateAverageTime();
                        setTimeout(generateQuestion, 900);
                        return;
                    }

                    document.getElementById('feedback').innerHTML =
                        `‚ùå Incorrect!<br><strong>Borrowed chord:</strong> ${progressionBorrowedChord}`;
                    updateScore(); updateAverageTime();
                    return;
                }

                // hard/competition: "C ionian | Abmaj7"
                const parts = userAnswerRaw.split("|").map(p => p.trim());
                const scalePart = parts[0] || "";
                const chordPart = parts[1] || "";

                const scaleOk = isScaleMatch(scalePart);
                const chordOk = normalize(chordPart) === normalize(progressionBorrowedChord);

                if (scaleOk && chordOk) {
                    correctCount++;
                    document.getElementById('feedback').innerText = "‚úÖ Correct!";
                    updateScore(); updateAverageTime();
                    setTimeout(generateQuestion, 900);
                    return;
                }

                document.getElementById('feedback').innerHTML =
                    `‚ùå Incorrect!<br><strong>Answer:</strong> ${progressionRoot} ${prettyScale} | ${progressionBorrowedChord}`;

                updateScore(); updateAverageTime();
                return;
            }

            // --- SCALE MODE FIRST ---
            if (currentMode === 'scale') {
                if (!correctNotes.length) {
                    document.getElementById('feedback').innerText = "‚ùå Generate a scale first!";
                    return;
                }

                const userAnswer = document.getElementById('userInput').value.trim();
                clearInterval(timer);
                const endTime = Date.now();
                const timeTaken = (endTime - startTime) / 1000;
                totalTimeSpent += timeTaken;
                answerCount++;
                totalCount++;

                const userPitchClasses = userAnswer.split(/\s+/).map(noteToPitchClass);
                const correctPitchClasses = correctNotes.map(noteToPitchClass);

                if (arraysEqual(userPitchClasses, correctPitchClasses)) {
                    correctCount++;
                    displayFeedback(true);
                    setTimeout(generateQuestion, 1000);
                } else {
                    displayFeedback(false);
                }

                updateScore();
                updateAverageTime();
                return; // stop here so chord logic doesn‚Äôt also run
            }

            // --- CHORD MODES (SPELL / NAME) ---
            if (!correctNotes.length) {
                document.getElementById('feedback').innerText = "‚ùå Generate a chord first!";
                return;
            }

            const userAnswer = document.getElementById('userInput').value.trim();
            clearInterval(timer);
            const endTime = Date.now();
            const timeTaken = (endTime - startTime) / 1000;
            totalTimeSpent += timeTaken;
            answerCount++;
            totalCount++;

            if (currentMode === 'spell') {
                const userPitchClasses = userAnswer.split(/\s+/).map(noteToPitchClass);
                const correctPitchClasses = correctNotes.map(noteToPitchClass);
                if (arraysEqual(userPitchClasses, correctPitchClasses)) {
                    correctCount++;
                    displayFeedback(true);
                    setTimeout(generateChord, 1000);
                } else {
                    displayFeedback(false);
                }
            } else if (currentMode === 'name') {
                if (userAnswer === `${root}${chordType}`) {
                    correctCount++;
                    displayFeedback(true);
                    setTimeout(generateChord, 1000);
                } else {
                    displayFeedback(false, true);
                }
            }

            updateScore();
            updateAverageTime();
        }

        function jazzSuffixFromQuality(q) {
            const exact = {
                // triads
                "Maj": "",
                "min": "‚àí",
                "dim": "dim",
                "aug": "+",
                "sus2": "sus2",
                "sus4": "sus4",

                // 6ths
                "6": "6",
                "min6": "‚àí6",
                "6/9": "6/9",
                "min6/9": "‚àí6/9",

                // 7ths
                "Maj7": "‚ñ≥7",
                "min7": "‚àí7",
                "7": "7",
                "halfdim7": "√∏7",
                "min7b5": "√∏7",
                "dim7": "o7",
                "minMaj7": "mM7",
                "minMaj9": "mM9",

                // extensions (plain)
                "9": "9",
                "Maj9": "‚ñ≥9",
                "min9": "‚àí9",
                "11": "11",
                "Maj11": "‚ñ≥11",
                "min11": "‚àí11",
                "13": "13",
                "Maj13": "‚ñ≥13",
                "min13": "‚àí13",

                // common majors with #11
                "Maj7#11": "‚ñ≥#11",
                "Maj9#11": "‚ñ≥9#11",

                // sus dominants
                "7sus4": "7sus4",
                "9sus4": "9sus4",
                "13sus4": "13sus4",

                // add chords
                "add9": "add9",
                "add11": "add11",
                "add#11": "add#11",
                "add13": "add13",
                "add4": "add4",
                "add6": "add6",
            };

            // exact hit (including empty string for Maj)
            if (q in exact) return exact[q];

            // helper: turn "b13#11" -> "(b13,#11)"
            const parenAlts = (rest) => {
                const tokens = (rest.match(/(bb|b|#)\d+/g) || []);
                return tokens.length ? `(${tokens.join(",")})` : "";
            };

            // 1) Dominant alterations: 7b9#11 -> 7(b9,#11)
            if (q.startsWith("7")) {
                const rest = q.slice(1);
                return "7" + parenAlts(rest);
            }

            // 2) Minor 7 alterations: min7b13 -> ‚àí7(b13)
            if (q.startsWith("min7")) {
                const rest = q.slice(4); // after "min7"
                return "‚àí7" + parenAlts(rest);
            }

            // 3) Major 7 alterations: Maj7#11 -> ‚ñ≥(#11) (unless exact already handled)
            if (q.startsWith("Maj7")) {
                const rest = q.slice(4);
                // common chart style is ‚ñ≥#11 (no parens) but parens are fine too
                const alt = parenAlts(rest);
                return "‚ñ≥" + (alt ? alt : "");
            }

            // 4) Minor (triad) alterations: minb6 etc (rare) ‚Äì fallback
            if (q.startsWith("min")) {
                const rest = q.slice(3);
                return "‚àí" + rest;
            }

            // fallback
            return q;
        }


        function formatChordJazz(root, quality) {
            return `${root}${jazzSuffixFromQuality(quality)}`;
        }

        function prettyChordString(chordName) {
            // chordName like "Cmin7" or "DbMaj7#11" (root + quality glued)
            const m = chordName.match(/^([A-G][#b]{0,2})(.*)$/);
            if (!m) return chordName;
            const root = m[1];
            const q = m[2];
            return formatChordJazz(root, q);
        }
        function displayFeedback(isCorrect, isNameMode = false) {
            const numNotes = correctNotes.length;
            const noteRow = correctNotes.map(n => `<div class="chord-cell">${n}</div>`).join('');

            // --- build intervalRow (your new logic already here) ---
            let intervalRow;
            if (currentMode === 'scale') {
                const has = new Set(intervals);
                const pickLabel = (pc) => {
                    switch (pc) {
                        case 0: return '1'; case 1: return 'b2'; case 2: return '2';
                        case 3: return 'b3'; case 4: return '3'; case 5: return '4';
                        case 6: return has.has(7) ? '#4' : 'b5';
                        case 7: return '5';
                        case 8: return has.has(9) ? '#5' : 'b6';
                        case 9: return '6'; case 10: return 'b7'; case 11: return '7';
                        default: return pc;
                    }
                };
                intervalRow = intervals.map(v => `<div class="chord-cell">${pickLabel(v)}</div>`).join('');
            } else {
                const chordLabels = {
                    0: '1', 1: 'b2', 2: '2', 3: 'b3', 4: '3', 5: '4',
                    6: '#4/b5', 7: '5', 8: '#5/b6', 9: '6', 10: 'b7', 11: '7',
                    13: 'b9', 14: '9', 15: '#9', 17: '11', 18: '#11', 20: 'b13', 21: '13'
                };
                intervalRow = intervals
                    .map(v => `<div class="chord-cell">${chordLabels[v] ?? v}</div>`)
                    .join('');
            }

            // --- build stepsRow (this was missing) ---
            const stepsRow = intervals
                .map((v, i) => (i === 0 ? '' : `+${v - intervals[i - 1]}`))
                .map(txt => `<div class="chord-cell">${txt}</div>`)
                .join('');

            const semitoneRow = intervals.map(v => `<div class="chord-cell">${v}</div>`).join('');

            if (isCorrect) {
                document.getElementById('feedback').innerText = "‚úÖ Correct!";
            } else {
                document.getElementById('feedback').innerHTML = `
      ‚ùå Incorrect!<br>
      ${isNameMode ? `<strong>Correct Chord:</strong> ${formatChordJazz(root, chordType)}<br><br>` : ''}
      <div class="chord-grid">
        <div class="chord-label">Correct Notes:</div>
        <div class="chord-row" style="grid-template-columns: repeat(${numNotes}, 1fr);">${noteRow}</div>
        <div class="chord-label">Intervals:</div>
        <div class="chord-row" style="grid-template-columns: repeat(${numNotes}, 1fr);">${intervalRow}</div>
        <div class="chord-label">Formula:</div>
        <div class="chord-row" style="grid-template-columns: repeat(${numNotes}, 1fr);">${stepsRow}</div>
        <div class="chord-label">Semitones (Root):</div>
        <div class="chord-row" style="grid-template-columns: repeat(${numNotes}, 1fr);">${semitoneRow}</div>
      </div>
    `;
            }
        }


        function updateAverageTime() {
            const average = answerCount === 0 ? '--' : (totalTimeSpent / answerCount).toFixed(2);
            document.getElementById('averageTimeDisplay').innerText = `Average Time: ${average}s`;
        }

        function updateScore() {
            document.getElementById('scoreDisplay').innerText = `Score: ${correctCount} / ${totalCount}`;
        }

        function toggleHelp() {
            document.getElementById('helpPopup').classList.toggle('hidden');
        }

        // Initialize once the DOM is fully loaded
        document.addEventListener("DOMContentLoaded", function () {
            document.getElementById('menuScreen').classList.remove('hidden');
            document.getElementById('appScreen').classList.add('hidden');
            updateToggleUI();

            const form = document.getElementById('answerForm');
            if (form) {
                form.addEventListener('submit', function (e) {
                    e.preventDefault();
                    checkAnswer();
                });
            }
        });

        function resetStats() {
            clearInterval(timer);
            correctNotes = [];
            intervals = [];
            harmonyTargetDegree = null;
            harmonyCorrectNote = null;
            harmonyDegreeRoman = null;
            harmonyChordName = null;
            harmonyChordQuality = null;
            harmonyChordRoot = null;

            correctCount = 0;
            totalCount = 0;
            totalTimeSpent = 0;
            answerCount = 0;

            updateScore();
            updateAverageTime();

            document.getElementById('feedback').innerText = "";
            document.getElementById('userInput').value = "";
            document.getElementById('timerDisplay').innerText = "Timer: --s";
        }

        function toggleModeToggle() {
            if (currentMode === 'degrees') {
                outOfScaleAllowed = !outOfScaleAllowed;
            } else {
                shellModeActive = !shellModeActive;
            }
            updateToggleUI();
        }

        function updateToggleUI() {
            const wrapper = document.querySelector('.shell-toggle-wrapper');
            const checkbox = document.getElementById('shellCheckbox');
            const label = document.getElementById('shellToggle');

            // Hide in Scales and Harmony (for now)
            if (currentMode === 'scale' || currentMode === 'harmony') {
                wrapper.style.display = 'none';
                return;
            }

            wrapper.style.display = 'flex';

            if (currentMode === 'degrees') {
                checkbox.innerText = outOfScaleAllowed ? '‚òëÔ∏è' : '‚òê';
                label.innerText = 'Out-of-scale';
                label.style.color = outOfScaleAllowed ? 'black' : '#aaa';
            } else {
                checkbox.innerText = shellModeActive ? '‚òëÔ∏è' : '‚òê';
                label.innerText = 'üêö Shell Mode';
                label.style.color = shellModeActive ? 'black' : '#aaa';
            }
        }

        function parseChordAnswer(raw) {
            const s = (raw || "").trim();
            const m = s.match(/^([A-Ga-g])([#b]{0,2})(.*)$/);
            if (!m) return null;

            const letter = m[1].toUpperCase();
            const acc = m[2] || "";
            const restRaw = (m[3] || "").trim();

            const rootNote = letter + acc;
            const rootPC = noteToPitchClass(rootNote);

            const rest = restRaw.replaceAll(" ", "");
            const restLower = rest.toLowerCase();

            let qualityKey = null;

            if (restLower.includes("m7b5") || restLower.includes("min7b5") || rest.includes("√∏7") || restLower.includes("halfdim")) {
                qualityKey = "halfdim7";
            } else if (restLower.includes("dim7") || rest.includes("¬∞7") || restLower.includes("o7") || restLower === "dim") {
                qualityKey = "dim7";
            } else if (restLower.includes("minmaj7") || restLower.includes("mmaj7") || restLower.includes("m(maj7)")) {
                qualityKey = "minMaj7";
            } else if (restLower === "7" || restLower.includes("dom7")) {
                qualityKey = "7";
            } else if (restLower.includes("maj7") || restLower.includes("ma7") || restRaw.includes("M7") || rest.includes("Œî7")) {
                qualityKey = "Maj7";
            } else if (restLower.includes("min7") || (restLower.includes("m7") && !restLower.includes("maj7")) || restLower.includes("-7")) {
                qualityKey = "min7";
            } else if (restLower === "" || restLower === "maj") {
                qualityKey = "Maj";
            } else if (restLower === "min" || restLower === "m") {
                qualityKey = "min";
            }

            return { rootPC, qualityKey };
        }


        function generateDegrees() {
            const difficulty = document.getElementById('difficulty').value;

            fetch(`/generate_degrees?difficulty=${difficulty}&out_of_scale=${outOfScaleAllowed}`)
                .then(response => response.json())
                .then(data => {
                    root = data.root;
                    const scaleType = data.scale_type;
                    const pretty = scaleType.replaceAll('_', ' ');

                    harmonyTargetDegree = data.target_degree;
                    harmonyCorrectNote = data.correct_note;

                    correctNotes = data.scale_notes || [];
                    intervals = data.scale_intervals || [];

                    document.getElementById('chordDisplay').innerText =
                        `In ${root} ${pretty}, what is the ${harmonyTargetDegree}?`;

                    document.getElementById('feedback').innerText = "";
                    document.getElementById('userInput').value = "";
                    startTimer(difficulty);
                    startTime = Date.now();
                })
                .catch(err => {
                    console.error(err);
                    document.getElementById('feedback').innerText = "‚ùå Failed to get a degrees question.";
                });
        }

        function generateHarmonyChord() {
            const difficulty = document.getElementById('difficulty').value;

            fetch(`/generate_harmony?difficulty=${difficulty}`)
                .then(response => response.json())
                .then(data => {
                    root = data.root;
                    const scaleType = data.scale_type;
                    const pretty = scaleType.replaceAll('_', ' ');

                    harmonyDegreeRoman = data.degree;
                    harmonyChordName = data.chord_name;
                    harmonyChordQuality = data.chord_quality;
                    harmonyChordRoot = data.chord_root;

                    correctNotes = data.scale_notes || [];
                    intervals = data.scale_intervals || [];

                    document.getElementById('chordDisplay').innerText =
                        `In ${root} ${pretty}, what is the ${harmonyDegreeRoman} chord?`;

                    document.getElementById('feedback').innerText = "";
                    document.getElementById('userInput').value = "";
                    startTimer(difficulty);
                    startTime = Date.now();
                })
                .catch(err => {
                    console.error(err);
                    document.getElementById('feedback').innerText = "‚ùå Failed to get a harmony question.";
                });
        }

        function generateQuestion() {
            const difficulty = document.getElementById('difficulty').value;
            updateToggleUI();

            if (currentMode === 'degrees') {
                generateDegrees();
                return;
            }

            if (currentMode === 'harmony') {
                generateHarmonyChord();
                return;
            }

            if (currentMode === 'progression') {
                generateProgression();
                return;
            }

            if (currentMode === 'scale') {
                fetch(`/generate_scale?difficulty=${difficulty}`)
                    .then(response => response.json())
                    .then(data => {
                        root = data.root;
                        const scaleType = data.scale_type;
                        correctNotes = data.correct_notes;
                        intervals = data.intervals;

                        const pretty = scaleType.replaceAll('_', ' ');
                        document.getElementById('chordDisplay').innerText =
                            `Spell the notes in: ${root} ${pretty} scale`;

                        document.getElementById('feedback').innerText = "";
                        document.getElementById('userInput').value = "";
                        startTimer(difficulty);
                        startTime = Date.now();
                    })
                    .catch(err => {
                        console.error(err);
                        document.getElementById('feedback').innerText = "‚ùå Failed to get a scale. Check console.";
                    });

                return;
            }

            // chord modes (‚Äúspell‚Äù / ‚Äúname‚Äù)
            generateChord();
        }

    </script>
</body>

</html>